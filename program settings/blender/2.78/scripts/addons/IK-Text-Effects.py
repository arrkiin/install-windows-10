""" -TODO-x custom fontx sync text char  x add text / multy text on 3D scenex del textx change style interpolation on the flyx Animat Loc/Rot/Scale independentlyx reload builded scenex random movex type effect x lock position x hide extrax auto kill non baked text x jump to root text / LOC_obj selectx button aligne value loc rot scl videx au moins deux chars pour pouvoir ajouter un textx Resolution fontx materiau quand on ref---- 3D object as font- change text on the fly / code effet - changement font on the fly- optimiser bake, key frame seument sur la plage du text"""bl_info = {    "name": "IK-Text Effects",    "author": "IK3D -- Issanou Kamardine",    "version": (0, 58),    "blender": (2, 74, 0),    "location": "View3D > IK-Text Effects",    "description": "Parametric text effects for motion designers",    "category": "Motion Design",    #"warning": "",    #"wiki_url": "",    }import bpyimport mathimport randomimport selection_utilsfrom random import randintfrom mathutils import Vectorfrom mathutils import Matrixfrom bpy.app.handlers import persistentfrom bpy.props import (EnumProperty,                       PointerProperty,                       StringProperty,)from bpy.types import (Panel,                       PropertyGroup,)ow, sin, cos, pi, sqrt, asin  = math.pow, math.sin, math.cos, math.pi, math.sqrt, math.asin#------------------------ Interpolation stufs -------------- def IIID_Vector(obj0, obj1, LRS):    """buld 3D vector"""    if LRS == 0 : #Loc        x1, y1, z1 = obj1.matrix_world.translation           x2, y2, z2 = obj0.matrix_world.translation           return Vector(( x2-x1, y2-y1, z2-z1 ))        if LRS == 1 : #Rot        vec    = Vector(( obj0.rotation_euler[0], obj0.rotation_euler[1], obj0.rotation_euler[2] ))        vecNeg = vec * -1        x1, y1, z1 = vecNeg        x2, y2, z2 = vec        return Vector(( x2-x1, y2-y1, z2-z1 ))        if LRS == 2 : #Scale        x1, y1, z1 = obj1.matrix_world.to_scale()        x2, y2, z2 = obj0.matrix_world.to_scale()        return Vector(( x2-x1, y2-y1, z2-z1 ))    def clas():    class text_options(bpy.types.PropertyGroup):           #Randozer fonction for Loc, Scal, Rot, Vide        def randL( self, context ):            l = eval(self.rand_loc_val)            random.shuffle( l )            self.rand_loc_val =  str(l)        def randR( self, context ):            l = eval(self.rand_rot_val)            random.shuffle( l )            self.rand_rot_val =  str(l)        def randS( self, context ):            l = eval(self.rand_scl_val)            random.shuffle( l )            self.rand_scl_val =  str(l)        def randV( self, context ):            l = eval(self.rand_vis_val)            random.shuffle( l )            self.rand_vis_val =  str(l)        #Common        full_txt    = bpy.props.StringProperty(name="Body text", default  = "IK-Text Effects")        charS_ob_nm        = bpy.props.StringProperty(name="Root obj name", default  = ",")        vis_on             = bpy.props.BoolProperty( default=False, description = "Toggl run visibility")#list[chars sorted]                #Animation        wiggle_OnLoc = bpy.props.BoolProperty(name="Wiggle position", default= False, description = "Wiggle on position")        wiggle_OnRot       = bpy.props.BoolProperty(name="Wiggle rotation", default= False, description = "Wiggle on rotation")        wiggle_OnScl       = bpy.props.BoolProperty(name="Wiggle scale", default= False, description = "Wiggle on scale")        wiggle_OnLoc_lock = bpy.props.BoolProperty(name="Wiggle loc lock", default= True, description = "lock location")        wiggle_OnRot_lock       = bpy.props.BoolProperty(name="Wiggle rot lock", default= True, description = "lock")        wiggle_OnScl_lock       = bpy.props.BoolProperty(name="Wiggle scl lock", default= True, description = "lock")                # V.ectors L.cation        wiggle_TVL         = bpy.props.FloatVectorProperty \                            (                                   name="Wiggle Location",                                 description="Frequency, Amplitude, Probability",                                 default=(0.3, 0.2, 1), min=0.0, max=10.0,step=3,                                 precision=2, options={'ANIMATABLE'}, subtype='NONE',                                 size=3, update=None                            )                wiggle_TVR         = bpy.props.FloatVectorProperty \                            (                                   name="Wiggle rotation",                                 description="Frequency, Amplitude, Probability",                                 default=(0.3, 0.2, 0.5), min=0.0, max=10.0,step=3,                                 precision=2, options={'ANIMATABLE'}, subtype='NONE',                                 size=3, update=None                            )                wiggle_TVS         = bpy.props.FloatVectorProperty \                            (                                   name="Wiggle scale",                                 description="Frequency, Amplitude, Probability",                                 default=(0.3, 0.2, 0.5), min=0.0, max=10.0,step=3,                                 precision=2, options={'ANIMATABLE'}, subtype='NONE',                                 size=3, update=None                            )        #Time Ofset for eache char // not used in the UI        wiggle_TimeL  = bpy.props.StringProperty(name="Wiggle time Loc", default="[]", description="List[ Char[F,A,P] ] # as Time ofset for 1 char ")        wiggle_TimeR  = bpy.props.StringProperty(name="Wiggle time Rot", default="[]", description="List[ Char[F,A,P] ] ")        wiggle_TimeS  = bpy.props.StringProperty(name="Wiggle time Scl", default="[]", description="List[ Char[F,A,P] ] ")               #Animation        start_at  = bpy.props.IntProperty(name="Frame start loc", default=20, min=0, max=80000000)        rot_start_at      = bpy.props.IntProperty(name="Frame start rot", default=20, min=0, max=80000000)        scl_start_at      = bpy.props.IntProperty(name="Frame start scale", default=20, min=0, max=80000000)        visibility_at     = bpy.props.IntProperty(name="Frame start vide", default  = 20, min=0, max=5000)        ofs           = bpy.props.IntProperty(name="Ofset loc", default  = 1, min=0, max=5000)        rot_ofs           = bpy.props.IntProperty(name="Ofset rot", default  = 1, min=0, max=5000)        scl_ofs           = bpy.props.IntProperty(name="Ofset scale", default  = 1, min=0, max=5000)        visibility_of     = bpy.props.IntProperty(name="Ofset vide", default  = 1, min=0, max=5000)        duration      = bpy.props.IntProperty(name="Duration loc", default  = 25, min=0, max=5000)        rot_duration      = bpy.props.IntProperty(name="Duration rot", default  = 25, min=0, max=5000)        scl_duration      = bpy.props.IntProperty(name="Duration scale", default  = 25, min=0, max=5000)        visibility_dt     = bpy.props.IntProperty(name="Duration vide", default  = 25, min=0, max=5000)        interpolation     = bpy.props.StringProperty(name="Interpolation loc", default  = "inOutBack")        rot_interpolation = bpy.props.StringProperty(name="Interpolation rot", default  = "inOutBack")        scl_interpolation = bpy.props.StringProperty(name="Interpolation scale", default  = "inOutBack")        vis_interpolation = bpy.props.StringProperty(name="vide vide", default  = "inOutBack")        back     = bpy.props.FloatProperty(name="Back loc", default  = 0.5, min=0.0, max=10.0, description = "Back effect on location")        rot_back          = bpy.props.FloatProperty(name="Back rot", default  = 0.5, min=0.0, max=10.0, description = "Back effect on rotation")        scl_back          = bpy.props.FloatProperty(name="Back scale", default  = 0.5, min=0.0, max=10.0, description = "Back effect on scale")        vis_back          = bpy.props.FloatProperty(name="Back vide", default  = 0.5, min=0.0, max=10.0, description = "Back effect on visibility")        rand_loc  = bpy.props.BoolProperty(name="Rand loc", default=False, description = "Enable random position", update=randL)#update=set radom                rand_rot          = bpy.props.BoolProperty(name="Rand rot", default=False, description = "Enable random rotation", update=randR)             rand_scl          = bpy.props.BoolProperty(name="Rand scalel", default=False, description = "Enable random scale", update=randS)          rand_vis          = bpy.props.BoolProperty(name="Rand vide", default=False, description = "Enable random visibility", update=randV)#update=set radom                rand_loc_val  = bpy.props.StringProperty(description = "Value of random in location")#list[chars sorted]        rand_rot_val      = bpy.props.StringProperty(description = "Value of random in rotation")        rand_scl_val      = bpy.props.StringProperty(description = "Value of random in scale")        rand_vis_val      = bpy.props.StringProperty(description = "Value of random in vide")#list[chars sorted]    return text_optionsdef recover(obname):    text_options = clas()    new = "{obn}=type('{obn}',text_options.__bases__,dict(text_options.__dict__))".format(obn = obname)    exec(new)    bpy.utils.register_class( eval(obname) )    exec("bpy.types.Scene.{obn} = bpy.props.CollectionProperty(type={obn})".format(obn = obname  ))    return eval(obname)def GroupsTextOptionsGenerator(obname):    text_options = clas()    new = "{obn}=type('{obn}',text_options.__bases__,dict(text_options.__dict__))".format(obn = obname)    exec(new)    bpy.utils.register_class( eval(obname) )    exec("bpy.types.Scene.{obn} = bpy.props.CollectionProperty(type={obn})".format(obn = obname  ))    return eval(obname)def deselect_others(ob, context):    """For tool menu select, deselects others if one selected"""    selected = IKTxtEffectsPanel.selected    ob[selected] = False    keys = [key for key in ob.keys() if ob[key]]  # all the True keys    if len(keys) <= 0:        ob[selected] = True  # reselect        return None    for key in keys:        IKTxtEffectsPanel.selected = key        ob[key] = True#bouton menu loc rot scalclass TxLocRotScl(bpy.types.PropertyGroup):    """Texts Options from C.scene.text_options"""    TXLoc = bpy.props.BoolProperty(name="location", default=False, description ="Desplay location settings", update=deselect_others)    TXRot = bpy.props.BoolProperty(name="rotation", default=False, description = "Desplay location rotation", update=deselect_others)    TXScl = bpy.props.BoolProperty(name="scale", default=False, description = "Desplay location scale", update=deselect_others)    TXVid = bpy.props.BoolProperty(name="vide", default=False, description = "Desplay location scale", update=deselect_others)def Tx_BuildSettings(target_txt):    # Générer Group option par obj    C = bpy.context    scene = C.scene    text_options = GroupsTextOptionsGenerator( target_txt.name )    exec( "C.scene.{}.add()".format( target_txt.name ) )    options = eval("C.scene.{}[0]".format( target_txt.name ))        if len(target_txt.data.body)>0:        options.full_txt = target_txt.data.body        return optionsdef linear(t, b, c, d):  return c * t / d + bdef inCubic(t, b, c, d):    t = t / d    return c * pow(t, 3) + bdef outCubic(t, b, c, d):    t = t / d - 1    return c * (pow(t, 3) + 1) + bdef inOutCubic(t, b, c, d):    t = t / d * 2    if t < 1 :        return c / 2 * t * t * t + b    else:        t = t - 2        return c / 2 * (t * t * t + 2) + bdef outInCubic(t, b, c, d):    if t < d / 2 :        return outCubic(t * 2, b, c / 2, d)    else:        return inCubic((t * 2) - d, b + c / 2, c / 2, d)def inQuart(t, b, c, d):    t = t / d    return c * pow(t, 4) + bdef outQuart(t, b, c, d):    t = t / d - 1    return -c * (pow(t, 4) - 1) + bdef inOutQuart(t, b, c, d):    t = t / d * 2    if t < 1 :        return c / 2 * pow(t, 4) + b    else:        t = t - 2        return -c / 2 * (pow(t, 4) - 2) + bdef outInQuart(t, b, c, d):    if t < d / 2 :        return outQuart(t * 2, b, c / 2, d)    else:        return inQuart((t * 2) - d, b + c / 2, c / 2, d)def inQuint(t, b, c, d):    t = t / d    return c * pow(t, 5) + bdef outQuint(t, b, c, d):    t = t / d - 1    return c * (pow(t, 5) + 1) + bdef inOutQuint(t, b, c, d):    t = t / d * 2    if t < 1 :        return c / 2 * pow(t, 5) + b    else:        t = t - 2        return c / 2 * (pow(t, 5) + 2) + bdef outInQuint(t, b, c, d):    if t < d / 2 :        return outQuint(t * 2, b, c / 2, d)    else:        return inQuint((t * 2) - d, b + c / 2, c / 2, d)def inSine(t, b, c, d):    return -c * cos(t / d * (pi / 2)) + c + b     def outSine(t, b, c, d):    return c * sin(t / d * (pi / 2)) + bdef inOutSine(t, b, c, d):    return -c / 2 * (cos(pi * t / d) - 1) + bdef outInSine(t, b, c, d):    if t < d / 2 :        return outSine(t * 2, b, c / 2, d)    else:        return inSine((t * 2) -d, b + c / 2, c / 2, d)def inExpo(t, b, c, d):    if t == 0 :        return b    else:        return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001def outExpo(t, b, c, d):    if t == d :        return b + c    else:        return c * 1.001 * (-pow(2, -10 * t / d) + 1) + bdef inOutExpo(t, b, c, d):    if t == 0 : return b     if t == d : return b + c     t = t / d * 2    if t < 1 :        return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005    else:        t = t - 1        return c / 2 * 1.0005 * (-pow(2, -10 * t) + 2) + bdef outInExpo(t, b, c, d):    if t < d / 2 :        return outExpo(t * 2, b, c / 2, d)    else:        return inExpo((t * 2) - d, b + c / 2, c / 2, d)def inCirc(t, b, c, d):    t = t / d    return -c * (sqrt(1 - t*t) - 1) + bdef outCirc(t, b, c, d):    t = t / d - 1    return c * sqrt(1 - t*t) + bdef inOutCirc(t, b, c, d):    t = t / d * 2    if t < 1 :        return -c / 2 * (sqrt(1 - t * t) - 1) + b    else:        t = t - 2        return c / 2 * (sqrt(1 - t * t) + 1) + bdef outInCirc(t, b, c, d):    if t < d / 2 :        return outCirc(t * 2, b, c / 2, d)    else:        return inCirc((t * 2) - d, b + c / 2, c / 2, d)def inElastic(t, b, c, d):     s=1.70158    p=0    a=c    if(t==0):        return b    t = t/d    if (t==1):        return b+c    p=d*.3;    a=c    s=p/4    t = t-1    return -(a*math.pow(2,10*(t)) * math.sin( (t*d-s)*(2*math.pi)/p )) + b;def outElastic(t, b, c, d):    if (t==0) :        return b;     t=t/d     if (t==1):        return b+c;      p=d*.3;    a=c;     s=p/4;    return (a*pow(2,-10*t) * math.sin( (t*d-s)*(2*math.pi)/p ) + c + b);def inOutElastic(t, b, c, d):    if (t==0):        return b;    t=t/(d/2)    if (t==2):        return b+c;     p=d*(.3*1.5);    a=c;     s=p/4;         if (t < 1):        t=t-1        postFix =a*pow(2,10*(t)); # postIncrement is evil        return -.5*(postFix* math.sin( (t*d-s)*(2*math.pi)/p )) + b;    t=t-1    postFix =  a*pow(2,-10*(t)); # postIncrement is evil    return postFix * math.sin( (t*d-s)*(2*math.pi)/p )*.5 + c + b;def inBack(t, b, c, d, s):    if not s : s = 1.70158     t = t / d    return c * t * t * ((s + 1) * t - s) + bdef outBack(t, b, c, d, s):    if not s : s = 1.70158     t = t / d - 1    return c * (t * t * ((s + 1) * t + s) + 1) + bdef inOutBack(t, b, c, d, s):    if not s : s = 1.70158     s = s * 1.525    t = t / d * 2    if t < 1 :        return c / 2 * (t * t * ((s + 1) * t - s)) + b    else:        t = t - 2        return c / 2 * (t * t * ((s + 1) * t + s) + 2) + bdef outInBack(t, b, c, d, s):    if t < d / 2 :        return outBack(t * 2, b, c / 2, d, s)    else:        return inBack((t * 2) - d, b + c / 2, c / 2, d, s)def outBounce(t, b, c, d, VN):    t = t / d    if t < 1 / 2.75:        return c * (7.5625 * t * t) + b    elif t < 2 / 2.75  :        t = t - (1.5 / 2.75)        return c * (7.5625 * t * t + 0.75) + b    elif t < 2.5 / 2.75 :        t = t - (2.25 / 2.75)        return c * (7.5625 * t * t + 0.9375) + b    else:        t = t - (2.625 / 2.75)        return c * (7.5625 * t * t + 0.984375) + bdef inBounce(t, b, c, d, VN):  return c - outBounce(d - t, VN, c, d, VN) + bdef inOutBounce(t, b, c, d, VN):    if t < d / 2:        return inBounce(t * 2, VN, c, d, VN) * 0.5 + b    else:        return outBounce(t * 2 - d, VN, c, d, VN) * 0.5 + c * .5 + bdef outInBounce(t, b, c, d, VN):    if t < d / 2:        return outBounce(t * 2, b, c / 2, d, VN)    else:        return inBounce((t * 2) - d, b + c / 2, c / 2, d, VN)def wiggle(Frequency, Amplitude, Probability, FA, FB, FC):    t = bpy.context.scene.frame_current     x , y, z = random.Random(t/ FA), random.Random(t/ FB), random.Random(t/ FC)    #animated    xU , yU, zU = random.Random(FA), random.Random(FB), random.Random(FC) #fix    rX, rY, rZ = 0, 0, 0    if abs( x.uniform(-1, 1) ) < Probability : rX = ( math.cos( t * ( xU.uniform(0, Frequency /10.0) ) ) + ( x.uniform(-1, 1) * Probability ) /10.0 ) * x.uniform( 0, Amplitude /100.0 )    if abs( y.uniform(-1, 1) ) < Probability : rY = ( math.cos( t * ( yU.uniform(0, Frequency /10.0) ) ) + ( y.uniform(-1, 1) * Probability ) /10.0 ) * y.uniform( 0, Amplitude /100.0 )    if abs( z.uniform(-1, 1) ) < Probability : rZ = ( math.cos( t * ( zU.uniform(0, Frequency /10.0) ) ) + ( z.uniform(-1, 1) * Probability ) /10.0 ) * z.uniform( 0, Amplitude /100.0 )    return (rX, rY, rZ)def Wiggled(WiggleMe, Frequency, Amplitude, Probability, FA, FB, FC):    x, y, z  = wiggle(Frequency, Amplitude, Probability, FA, FB, FC)    Wiggler  = Vector(( x, y, z ))    return WiggleMe + (- Wiggler )def resizeChild(ob, trgScale ):    try:        scale_ratio  = [ ng / g for ng, g in zip( trgScale, ob.matrix_world.to_scale()  ) ]        ob.scale     = [ axis * ratio for axis, ratio in zip( ob.scale, scale_ratio ) ]    except ZeroDivisionError:        pass    def MatchInterpo(inter, v):    # v = [t0, b1, c2, d3, s4, VN5 ]    if inter == "linear":        return linear(v[0], v[1], v[2], v[3])    if inter == "inCubic":        return inCubic(v[0], v[1], v[2], v[3])    if inter == "outCubic":        return outCubic(v[0], v[1], v[2], v[3])    if inter == "inOutCubic":        return inOutCubic(v[0], v[1], v[2], v[3])    if inter == "outInCubic":        return outInCubic(v[0], v[1], v[2], v[3])    if inter == "inQuart":        return inQuart(v[0], v[1], v[2], v[3])    if inter == "outQuart":        return outQuart(v[0], v[1], v[2], v[3])    if inter == "inOutQuart":        return inOutQuart(v[0], v[1], v[2], v[3])    if inter == "outInQuart":        return outInQuart(v[0], v[1], v[2], v[3])    if inter == "inQuint":        return inQuint(v[0], v[1], v[2], v[3])    if inter == "outQuint":        return outQuint(v[0], v[1], v[2], v[3])    if inter == "inOutQuint":        return inOutQuint(v[0], v[1], v[2], v[3])    if inter == "outInQuint":        return outInQuint(v[0], v[1], v[2], v[3])    if inter == "inSine":        return inSine(v[0], v[1], v[2], v[3])    if inter == "outSine":        return outSine(v[0], v[1], v[2], v[3])    if inter == "inOutSine":        return inOutSine(v[0], v[1], v[2], v[3])    if inter == "outInSine":        return outInSine(v[0], v[1], v[2], v[3])    if inter == "inExpo":        return inExpo(v[0], v[1], v[2], v[3])    if inter == "outExpo":        return outExpo(v[0], v[1], v[2], v[3])    if inter == "inOutExpo":        return inOutExpo(v[0], v[1], v[2], v[3])    if inter == "outInExpo":        return outInExpo(v[0], v[1], v[2], v[3])    if inter == "inCirc":        return inCirc(v[0], v[1], v[2], v[3])    if inter == "outCirc":        return outCirc(v[0], v[1], v[2], v[3])    if inter == "inOutCirc":        return inOutCirc(v[0], v[1], v[2], v[3])    if inter == "outInCirc":        return outInCirc(v[0], v[1], v[2], v[3])    if inter == "inElastic":        return inElastic(v[0], v[1], v[2], v[3])    if inter == "outElastic":        return outElastic(v[0], v[1], v[2], v[3])    if inter == "inOutElastic":        return inOutElastic(v[0], v[1], v[2], v[3])    # if inter == "outInElastic":    #     return outInElastic(v[0], v[1], v[2], v[3])    if inter == "inBack":        return inBack(v[0], v[1], v[2], v[3], v[4])    if inter == "outBack":        return outBack(v[0], v[1], v[2], v[3], v[4])    if inter == "inOutBack":        return inOutBack(v[0], v[1], v[2], v[3], v[4])    if inter == "outInBack":        return outInBack(v[0], v[1], v[2], v[3], v[4])    if inter == "outBounce":        return outBounce(v[0], v[1], v[2], v[3], v[5])    if inter == "inBounce":        return inBounce(v[0], v[1], v[2], v[3], v[5])    if inter == "inOutBounce":        return inOutBounce(v[0], v[1], v[2], v[3], v[5])    if inter == "outInBounce":        return outInBounce(v[0], v[1], v[2], v[3], v[5])def delUnUsable(name):    S = scene   = bpy.context.scene    CC = context = bpy.context    Disque = eval(scene.IKAnimatedTx)    A, B, C = name, name + "_LOC", name + "_LOCKED"     vital = [ A, B, C ]    if A in CC.scene.objects: vital.remove( A )    if B in CC.scene.objects: vital.remove( B )    if C in CC.scene.objects: vital.remove( C )    if ( len(vital) == 0 ) or ( ( len(vital) == 1 ) and ( C in vital ) ) : return False        if A or B in vital:        if name in Disque:            del Disque[name]            bpy.context.scene.IKAnimatedTx = str(Disque)                allOb = [ o for o in CC.scene.objects if o.name.startswith(name)]        bpy.ops.object.select_all(action='DESELECT')        for ob in allOb:            if ob == None : continue #echap les objets qui existe pas            ob.hide_select, ob.select = False, True            bpy.ops.object.delete(use_global=False)        if getattr(scene,  name , None) != None :            exec( "del bpy.types.Scene.{p}".format( p = A ) )        return True@persistentdef IkTx_LOC(scene):    # [ txt_char.name, start_trg.name, end_trg.name, idx ]     C = bpy.context    scene = C.scene    Disque = eval(scene.IKAnimatedTx)    start  = C.scene.frame_start    t = C.scene.frame_current    for Settings in Disque:        name = Settings        if delUnUsable(name): break        if getattr(scene,  name , None) == None :            continue                Settings = eval('scene.{S}[0]'.format( S=Settings ) )                for sett in Disque[ name ]:            obj_text  = bpy.data.objects[ sett[0] ]            end_trg   = bpy.data.objects[ sett[0] + "_ed_Trg" ]            start_trg = bpy.data.objects[ sett[0] + "_st_Trg" ]            idx       = sett[3]            V_ref     = IIID_Vector(end_trg, start_trg, 0)            if Settings.rand_loc :                 i=eval(Settings.rand_loc_val)                loc_idx = i[idx];            else: loc_idx = idx;            StrAt = Settings.start_at + ( Settings.ofs *loc_idx)            if t <= StrAt:                obj_text.matrix_world.translation = start_trg.matrix_world.translation             else:                if ( t > StrAt  and  t  <  StrAt + Settings.duration ) and (V_ref.magnitude > 0.005):                    loc = MatchInterpo( Settings.interpolation, [ (t-StrAt), start_trg.matrix_world.translation , V_ref, Settings.duration, Settings.back , Vector((0,0,0)) ]) #animed                else:                    if Settings.wiggle_OnLoc_lock : loc =  MatchInterpo( Settings.interpolation, [ Settings.duration , start_trg.matrix_world.translation , V_ref, Settings.duration, Settings.back , Vector((0,0,0)) ])                      else: loc = obj_text.matrix_world.translation #curant pose                if Settings.wiggle_OnLoc:                    vec = Settings.wiggle_TVL #match user param                    FAFBFC = eval(Settings.wiggle_TimeL)                    Frequency, Amplitude, Probability, FA, FB, FC = vec[0], vec[1], vec[2], FAFBFC[loc_idx][0], FAFBFC[loc_idx][1], FAFBFC[loc_idx][2]                    loc = Wiggled(loc, Frequency, Amplitude, Probability, FA, FB, FC)                obj_text.matrix_world.translation = loc@persistentdef IkTx_ROT(scene):    # [ txt_char.name, start_trg.name, end_trg.name, idx ]     C = bpy.context    scene = C.scene    Disque = eval(scene.IKAnimatedTx)    start  = C.scene.frame_start    t = C.scene.frame_current     for Settings in Disque:        name = Settings        if delUnUsable(name): break        if getattr(scene,  name , None) == None :            continue        Settings = eval('scene.{S}[0]'.format( S = name ) )                for sett in Disque[ name ]:             obj_text  = bpy.data.objects[ sett[0] ]            end_trg   = bpy.data.objects[ sett[0] + "_ed_Trg" ]            start_trg = bpy.data.objects[ sett[0] + "_st_Trg" ]            idx       = sett[3]            rotat = bpy.context.scene.objects[ name + "_LOC" ].rotation_euler             b_rot = Vector(( rotat[0], rotat[1], rotat[2] ))            V_ref_R  = IIID_Vector(end_trg, start_trg, 1)            if Settings.rand_rot:                 i=eval(Settings.rand_rot_val)                rot_idx = i[idx];            else: rot_idx = idx;            r_StrAt = Settings.rot_start_at  + (Settings.rot_ofs *rot_idx)            #Rotation            if t > r_StrAt  and  t  <  r_StrAt + Settings.rot_duration :                rot_line = MatchInterpo( Settings.rot_interpolation, [(t-r_StrAt), V_ref_R, b_rot, Settings.rot_duration, Settings.rot_back, 0])            else:                 if Settings.wiggle_OnRot_lock :                     rot_line = MatchInterpo( Settings.rot_interpolation, [ Settings.rot_duration , V_ref_R, b_rot, Settings.rot_duration, Settings.rot_back, 0])                    rot_line = Vector(( ( b_rot[0] - rot_line[0] ), ( b_rot[1] - rot_line[1] ), ( b_rot[2] - rot_line[2] ) ))                else: rot_line = Vector( obj_text.rotation_euler[0:3] )                            if Settings.wiggle_OnRot:                vec = Settings.wiggle_TVR #match user param                FAFBFC = eval(Settings.wiggle_TimeR)                Frequency, Amplitude, Probability, FA, FB, FC = vec[0], vec[1], vec[2], FAFBFC[rot_idx][0], FAFBFC[rot_idx][1], FAFBFC[rot_idx][2]                rot_line = ( Wiggled( rot_line , Frequency, Amplitude, Probability, FA, FB, FC) ).to_tuple()            if t > r_StrAt  and  t  <  r_StrAt + Settings.rot_duration :                obj_text.rotation_euler = ( ( b_rot[0] - rot_line[0] ), ( b_rot[1] - rot_line[1] ), ( b_rot[2] - rot_line[2] ) )            else:                 if t <= r_StrAt :                    obj_text.rotation_euler = rotat                else: obj_text.rotation_euler = rot_line@persistentdef IkTx_SCL(scene):    C = bpy.context    scene = C.scene    Disque = eval(scene.IKAnimatedTx)    start  = C.scene.frame_start    t = C.scene.frame_current     for Settings in Disque:        name = Settings        if delUnUsable(name): break        if getattr(scene,  name , None) == None :            continue        Settings = eval('scene.{S}[0]'.format( S=Settings ) )                for sett in Disque[ name ]:                         txt_obj   = bpy.data.objects[ name ]            obj_text  = bpy.data.objects[ sett[0] ]            end_trg   = bpy.data.objects[ sett[0] + "_ed_Trg" ]            start_trg = bpy.data.objects[ sett[0] + "_st_Trg" ]            idx       = sett[3]            b_scal = bpy.context.scene.objects[ txt_obj.name + "_LOC" ].matrix_world.to_scale()            c_scal = txt_obj.scale            V_ref_S  = IIID_Vector(end_trg, start_trg, 2)            if Settings.rand_scl :                 i=eval(Settings.rand_scl_val)                scl_idx = i[idx];            else: scl_idx = idx;            s_StrAt   = Settings.scl_start_at  + ( Settings.scl_ofs *scl_idx)            #scale            if t <= s_StrAt:                resizeChild(obj_text, b_scal )            else:                if t > s_StrAt  and  t  <  s_StrAt + Settings.scl_duration :                    scl_line = MatchInterpo( Settings.scl_interpolation , [(t-s_StrAt),  b_scal , V_ref_S , Settings.scl_duration ,  Settings.scl_back , Vector((0,0,0))])                                else:                     if Settings.wiggle_OnScl_lock : scl_line = MatchInterpo( Settings.scl_interpolation , [ Settings.scl_duration ,  b_scal , V_ref_S , Settings.scl_duration ,  Settings.scl_back , Vector((0,0,0))])                    else: scl_line = Vector( obj_text.matrix_world.to_scale() )                if Settings.wiggle_OnScl:                    vec = Settings.wiggle_TVS #match user param                    FAFBFC = eval(Settings.wiggle_TimeS)                    Frequency, Amplitude, Probability, FA, FB, FC = vec[0], vec[1], vec[2], FAFBFC[scl_idx][0], FAFBFC[scl_idx][1], FAFBFC[scl_idx][2]                    scl_line = ( Wiggled( scl_line , Frequency, Amplitude, Probability, FA, FB, FC) ).to_tuple()                    scl_line = (abs(scl_line[0]), abs(scl_line[0]), abs(scl_line[0]))                resizeChild(obj_text, scl_line )@persistentdef IkTx_Vid(scene):    C = bpy.context    scene = C.scene    Disque = eval(scene.IKAnimatedTx)    start  = C.scene.frame_start    t = C.scene.frame_current     for Settings in Disque:        name = Settings        if delUnUsable(name): break        if getattr(scene,  name , None) == None :            continue        Settings = eval('scene.{S}[0]'.format( S=Settings ) )                for sett in Disque[ name ]:             obj_text  = bpy.data.objects[ sett[0] ]            end_trg   = bpy.data.objects[ sett[0] + "_ed_Trg" ]            start_trg = bpy.data.objects[ sett[0] + "_st_Trg" ]            idx       = sett[3]            if Settings.rand_vis :                 i=eval(Settings.rand_vis_val)                vis_idx = i[idx];            else: vis_idx = idx;                        #Vide            if t <=  Settings.visibility_at :                if Settings.vis_on : obj_text.hide , obj_text.hide_render = True, True                else: obj_text.hide, obj_text.hide_render = False, False            if Settings.vis_on:                if t >  Settings.visibility_at :                     obj_text.hide = False;                    obj_text.hide_render = False;                if ( Settings.visibility_at  +  Settings.visibility_dt *  Settings.visibility_of  ) > t >  Settings.visibility_at :                        call = MatchInterpo( Settings.vis_interpolation , [(t- Settings.visibility_at ), 0, len( Settings.full_txt ) *  Settings.visibility_of ,  Settings.visibility_dt *  Settings.visibility_of  , Settings.vis_back, 0])                                                if vis_idx >= int(call) :                             obj_text.hide , obj_text.hide_render = True, True                        else:                             obj_text.hide , obj_text.hide_render = False, Falsedef InitTxt(body, LFont):    """Build text root"""    C = bpy.context    scene = C.scene    area = C.area    old_type = area.type    area.type = 'VIEW_3D'#------------------------- place 3D cursor    bpy.ops.view3d.snap_cursor_to_center()      area.type = old_type    name = "".join([c for c in body.title() if c.isalpha()])    num  = len([o for o in C.scene.objects if o.name.startswith(name)] )    name = name + "".join( [chr( int(chif) + ord('A')) for chif in str(num)] ) + "_IK"     bpy.ops.object.text_add(view_align=False, enter_editmode=False, location=(0, 0, 0))    C.active_object.name = name    setFont(C.active_object, LFont)    bpy.data.objects[name].data.body = body    bpy.ops.object.select_all(action='DESELECT')    C.object.draw_type = 'BOUNDS'    bpy.context.object.hide_render = True    bpy.ops.object.empty_add(type='CONE', radius=0.2, location=(0, 0, 0))    C.active_object.name = name + "_LOC"    C.scene.objects.active = bpy.data.objects[name]    bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)    return name# >> ------------------ Kerning --------------------def loadFont():    path = str(bpy.context.scene.ik_font_path)     if len(path)>0:                try:            bpy.data.fonts.load(path)            loadedFont = [ p for p in bpy.data.fonts if p.filepath == path]        except RuntimeError:            print("Error Load font")            return []        return loadedFont    else:        return []def setFont(ob, Font):    if len(Font) > 0:        ob.data.font = Font[0]def kerning(Text, LFont):    """Build space character on 3D text analizing"""    C = bpy.context    scene = C.scene    Kerning = {}        c = None    for num in range(len(Text)):#escap all bar space        if not c == None:            if num < c:                continue        bpy.ops.object.text_add(view_align=False, enter_editmode=False )        ob_name = C.active_object.name = Text[0:3] +"_" + str(len(Kerning))          ob = scene.objects[ob_name]        setFont(ob, LFont)        if Text[num] == " ":            c=num                        while Text[c] == " ":                if c+1 < len(Text):                    c+=1                else:                    continue            if num > 0:                space = num - 1            ob.data.body   = Text[space:c+1]            C.scene.update()             spaceAndLettre = ob.dimensions[0]            ob.data.body   = Text[c]            ob.data.body   = Text[space]            C.scene.update()             SSString = ob.dimensions[0]            ob.data.body   = Text[c]            C.scene.update()             EndSSpace = ob.dimensions[0]            lettre = spaceAndLettre - SSString - EndSSpace            paire  = spaceAndLettre            Kerning[ num ] = [lettre,paire, Text[num]]            bpy.ops.object.delete(use_global=False)        else:            ob.data.body = Text[num]            C.scene.update()             lettre = ob.dimensions[0]            ob.data.body = Text[num: num+2]            C.scene.update()             paire  = ob.dimensions[0]            Kerning[ num ] = [lettre,paire, Text[num]]            bpy.ops.object.delete(use_global=False)    n = 0    allSpace=0    allSpaceKern = {}    for itm in Kerning:        char = True        try:            nxkey = itm+1            k = [k for k in Kerning.keys()]            if nxkey < len(k):                nxkey = k[nxkey]             if not Kerning[itm][2] == " ":                if Kerning[nxkey][2] == " ":                    kern = Kerning[itm][0]                 else:                    kern = Kerning[itm][1] - Kerning[nxkey][0]             else:                kern = Kerning[itm][0]                 char = False        except KeyError:            pass                allSpaceKern[itm] = allSpace        allSpace = allSpace + kern      return Kerning, allSpaceKern# >> ------------------ End Kerning -----------------def AddChar(Kerning, allSpaceKern, LFont, name):    """Add slised text"""    C = bpy.context    scene = C.scene    list_c = []    for c in Kerning:        if Kerning[c][2] == " ":#avoid space bare            continue        bpy.ops.object.text_add(view_align=False, enter_editmode=False )                ob_name = C.active_object.name = name + "_char_" + Kerning[c][2] +"_"+ str(len(list_c))        setFont(C.active_object, LFont)            list_c.append( [ob_name , c] )        ob = scene.objects[ob_name]        ob.data.body = Kerning[c][2]        C.scene.update()         try:            ob.location[0] = allSpaceKern[c]        except KeyError:            pass    for o_name in list_c:        char_ob = scene.objects[o_name[0]]        if char_ob.select == False:            char_ob.select = True    return list_c#Extra optionsdef SetUpChar(list_c,allSpaceKern,Settings,txt_obj, name_text):    """Make constraint and links for characters"""    C = bpy.context    scene = C.scene    Settings.charS_ob_nm = str( [c[0] for c in list_c] )        l=list(  range( 0, len( eval(Settings.charS_ob_nm) ) )  )    random.shuffle( l )    order =    str( l )    Settings.rand_loc_val = order    Settings.rand_rot_val = order    Settings.rand_scl_val = order    Settings.rand_vis_val = order    Settings.wiggle_TimeL = str(  [ [random.randrange(1,250) ,  random.randrange(1,250), random.randrange(1,250)] for d in range( len(list_c) ) ] )    Settings.wiggle_TimeR = str(  [ [random.randrange(1,250) ,  random.randrange(1,250), random.randrange(1,250)] for d in range( len(list_c) ) ] )    Settings.wiggle_TimeS = str(  [ [random.randrange(1,250) ,  random.randrange(1,250), random.randrange(1,250)] for d in range( len(list_c) ) ] )    #save classe name in str registred in blender    Disque = eval(bpy.context.scene.IKAnimatedTx)    #build handller    CharsSettings = []    idx         = 0     for o_name in list_c:        Rt_St   = "Rot_Start"        Rt_Ed   = "Rot_End"        Sl_St   = "Scal_Start"        Sl_Ed   = "Scal_End"                ob_ofst  = allSpaceKern[o_name[1]]        txt_char = bpy.data.objects[o_name[0]]        #target move start/end        bpy.ops.object.empty_add(type='SINGLE_ARROW', radius=0.05, location=(ob_ofst, 0, 0))        end_trg = C.active_object        end_trg.name = txt_char.name + "_ed_Trg"                txt_char.select =  True        C.scene.objects.active = bpy.data.objects[txt_char.name + "_ed_Trg"]        bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)        txt_char.select =  False        txt_char.hide_select = True        end_trg.hide_select  = True        C.scene.objects.active = bpy.data.objects[name_text]        bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)        bpy.ops.object.empty_add(type='SINGLE_ARROW', radius=0.05, location=(ob_ofst, 0, 0))        start_trg = C.active_object        start_trg.hide_select = True        start_trg.name = txt_char.name + "_st_Trg"        C.scene.objects.active = bpy.data.objects[ txt_obj.name + "_LOC" ]        bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)        CharsSettings.append( [ txt_char.name, start_trg.name, end_trg.name, idx ] )        #[ txt_char, end_trg, start_trg, Settings, idx, txt_obj ]        idx += 1       bpy.ops.object.select_all(action='DESELECT')    bpy.data.objects[name_text].select =  True    C.scene.objects.active = bpy.data.objects[name_text]    #save on disque    Disque[ txt_obj.name ] = CharsSettings    bpy.context.scene.IKAnimatedTx = str(Disque)    def ReloadHandler(Settings, txt_obj):    """Make constraint and links for characters"""    C = bpy.context    scene = C.scene    list_c = eval( Settings.charS_ob_nm )    idx         = 0     for o_name in list_c:        txt_char = bpy.data.objects[o_name]        #target move start/end        end_trg   = bpy.data.objects[ txt_char.name + "_ed_Trg" ]        start_trg = bpy.data.objects[ txt_char.name + "_st_Trg" ]        #build handller        idx += 1def getMaterial(child):    """Apply materials to children from Parent obj"""    obj   = bpy.context.active_object    Mat = None    for M in obj.data.materials:        Mat, MatN = M, M.name        break    if not Mat == None:        for ob in child:            if ob.type == 'FONT':                                 ob.data.materials.clear()                ob.data.materials.append(Mat)     else:        for ob in child:            if ob.type == 'FONT':                 ob.data.materials.clear()  def setCyclesV(obj):    obj.cycles_visibility.camera        = False    obj.cycles_visibility.diffuse       = False    obj.cycles_visibility.glossy        = False    obj.cycles_visibility.transmission  = False    obj.cycles_visibility.scatter       = False    obj.cycles_visibility.shadow        = Falseclass AddTxtOperator(bpy.types.Operator):    """Add IK text to 3D scene"""    bl_idname = "object.add_txt_operator"    bl_label = "Add 3D text"    bl_options = {'REGISTER', 'UNDO'}    # @classmethod    # def poll(cls, context):    #     return bpy.context.scene.auto_applay_dc  is not True     def execute(self, context):                        Text  = bpy.context.scene.edit_ik_text.rstrip() #recup text        if len(Text) < 2 : return {'CANCELLED'}        LFont = loadFont()        name_text = InitTxt(Text, LFont)        txt_obj   = bpy.data.objects[name_text]#root        setCyclesV(txt_obj)        Kerning, allSpaceKern = kerning(Text, LFont)        list_c   = AddChar(Kerning, allSpaceKern, LFont, name_text)            Settings = Tx_BuildSettings(txt_obj)        SetUpChar(list_c, allSpaceKern, Settings, txt_obj, name_text)                return {'FINISHED'}def text_prop_copier(context, chil_txt):    if context.active_object.type != 'FONT':        return False    active = bpy.data.curves[context.active_object.data.name]    for ob in chil_txt:        if ob.type == 'FONT':            text = bpy.data.curves[ob.data.name]            # collect names of writeable properties            properties = [p.identifier for p in active.bl_rna.properties if not p.is_readonly]            # copy those properties            for prop in properties:                if (not prop.startswith('texspace') ) and (prop != 'name') and (prop != 'body') :                    #print(prop, 'copied')                    setattr(text, prop, getattr(active, prop))    return Trueclass SyncCharOperator(bpy.types.Operator):    """Tooltip"""    bl_idname = "object.syncchar_operator"    bl_label = "Synchronize children characters"    bl_options = {'REGISTER', 'UNDO'}    @classmethod    def poll(cls, context):        return context.active_object is not None    def execute(self, context):        S = scene   = bpy.context.scene        C = context = bpy.context        if getattr(context.scene,  context.object.name , None) != None :            listChilds = eval(eval("C.scene.{A}[0].charS_ob_nm".format(A = C.active_object.name)))            childs = [bpy.data.objects[ _ ] for _ in listChilds]            text_prop_copier(context, childs)                else:             childs = C.object.children            text_prop_copier(context, childs)        getMaterial(childs)                return {'FINISHED'}class RecoverBackOperator(bpy.types.Operator):    """Relod from last session"""    bl_idname = "object.ik_tx_reload_op"    bl_label = "Reload animation from last session"    bl_options = {'REGISTER', 'UNDO'}    @classmethod    def poll(cls, context):        look = eval(context.scene.IKAnimatedTx)        return len(look) != 0    def execute(self, context):        Disque = eval(context.scene.IKAnimatedTx)        for ob in context.scene.objects:            if ob.name.endswith("_IK") and ob.name in Disque:                recover(ob.name)                sett = eval("context.scene.{o}[0]".format( o= ob.name ) )                ReloadHandler( sett , ob)        return {'FINISHED'}class KillTrackOperator(bpy.types.Operator):    """IK kill text track"""    bl_idname = "object.kil_tx_trk_op"    bl_label = "IK kill text track"    bl_options = {'REGISTER', 'UNDO'}    @classmethod    def poll(cls, context):        return context.active_object is not None    def execute(self, context):        name = context.active_object.name        #save classe name in str registred in blender        Disque = eval(bpy.context.scene.IKAnimatedTx)        del Disque[name]        bpy.context.scene.IKAnimatedTx = str(Disque)        return {'FINISHED'}class ErassTxOperator(bpy.types.Operator):    """Erase IK 3D text"""    bl_idname = "object.erase_tx_op"    bl_label = "Erase text"    bl_options = {'REGISTER', 'UNDO'}    @classmethod    def poll(cls, context):        obj=False        if context.active_object != None:            name = context.active_object.name            Disque = eval(context.scene.IKAnimatedTx)                        if name in Disque :                obj = True        return obj is not False    def execute(self, context):        S = scene   = bpy.context.scene        C = context = bpy.context        obj        = C.active_object        LOC_obj    = bpy.data.objects[obj.name+"_LOC"]        Lname      = LOC_obj.name + "KED"        if Lname in C.scene.objects:            LOCked = bpy.data.objects[Lname]        else: LOCked = None        start_trgS = [_ for _ in LOC_obj.children]        end_trgS   = [_ for _ in obj.children]        listChars  = eval(eval("C.scene.{A}[0].charS_ob_nm".format(A = C.active_object.name)))        charS      = [bpy.data.objects[ _ ] for _ in listChars]        all = charS + end_trgS + start_trgS + [LOCked]        all.append(LOC_obj)        all.append(obj)                bpy.ops.object.kil_tx_trk_op()        bpy.ops.object.select_all(action='DESELECT')        for ob in all:            if ob == None : continue #echap les objets qui existe pas            ob.hide_select, ob.select = False, True            bpy.ops.object.delete(use_global=False)        if getattr(scene,  obj.name , None) != None:           exec( "del bpy.types.Scene.{p}".format( p = obj.name ) )        return {'FINISHED'}class BakeTxOperator(bpy.types.Operator):    """Bake IK 3D text"""    bl_idname = "object.bake_tx_op"    bl_label = "IK Bake text"    bl_options = {'REGISTER', 'UNDO'}    @classmethod    def poll(cls, context):        obj=False        if context.active_object != None:            name = context.active_object.name            Disque = eval(context.scene.IKAnimatedTx)                        if name in Disque :                obj = True        return obj is not False    def execute(self, context):        S = scene   = bpy.context.scene        C = context = bpy.context        start = S.frame_start         end   = S.frame_end         S.frame_current         obj     = C.active_object        (lx,ly,lz) = obj.location        (rx,ry,rz) = obj.rotation_euler[0:3]        (sx,sy,sz) = obj.scale        LOC_obj = bpy.data.objects[obj.name+"_LOC"]        Lname   = LOC_obj.name + "KED"        if Lname in C.scene.objects:            LOCked = bpy.data.objects[Lname]        else: LOCked = None        start_trgS = [_ for _ in LOC_obj.children]        end_trgS   = [_ for _ in obj.children]        listChars  = eval(eval("C.scene.{A}[0].charS_ob_nm".format(A = C.active_object.name)))        charS      = [bpy.data.objects[ _ ] for _ in listChars]        obsolet_ob = end_trgS + start_trgS + [LOCked]        obsolet_ob.append(LOC_obj)                bpy.ops.object.location_clear()        bpy.ops.object.rotation_clear()        bpy.ops.object.scale_clear()        bpy.ops.object.select_all(action='DESELECT')        S.frame_current = start        for ob in charS:            if ob == None : continue #echap les objets qui existe pas            ob.hide_select, ob.select = False, True        while S.frame_current <= end:            S.frame_set(S.frame_current)# Update            C.scene.update()                        for c in charS:# keyframing                c.keyframe_insert("hide")                c.keyframe_insert("hide_render")                c.keyframe_insert("location")                c.keyframe_insert("rotation_euler")                c.keyframe_insert("scale")                                                            S.frame_current +=1        S.objects.active = bpy.data.objects[ obj.name ]        bpy.ops.object.parent_set(type='OBJECT', keep_transform=False)        obj.location        = (lx,ly,lz)          obj.rotation_euler  = (rx,ry,rz)          obj.scale           = (sx,sy,sz)          bpy.ops.object.select_all(action='DESELECT')        bpy.ops.object.kil_tx_trk_op()        for ob in obsolet_ob:            if ob == None : continue #echap les objets qui existe pas            ob.hide_select, ob.select = False, True            bpy.ops.object.delete(use_global=False)                if getattr(scene,  obj.name , None) == None :#del obj props           exec( "del bpy.types.Scene.{p}".format( p = obj.name ) )        obj.name = obj.name.replace('_IK', '')                  return {'FINISHED'}class PastOperator(bpy.types.Operator):    """Paste settings to others, align loc, rot, scale, vide """    bl_idname = "object.past_tx_operator"    bl_label = "Past settings to others"    bl_options = {'REGISTER', 'UNDO'}    @classmethod    def poll(cls, context):                obj = False        if context.active_object != None:            if '_IK' in context.active_object.name:                obj = True        return obj is not False    def execute(self, context):        A = ["start_at", "ofs", "duration", "full_txt", "charS_ob_nm", "interpolation",             "back", "rand_loc", "vis_on", "wiggle_OnLoc", "wiggle_TVL", "wiggle_OnLoc_lock"]        B = ["rot_start_at", "rot_ofs", "rot_duration", "full_txt", "charS_ob_nm", "rot_interpolation",             "rot_back", "rand_rot", "vis_on", "wiggle_OnRot", "wiggle_TVR", "wiggle_OnRot_lock"]        C = ["scl_start_at", "scl_ofs", "scl_duration", "full_txt", "charS_ob_nm", "scl_interpolation",             "scl_back", "rand_scl", "vis_on", "wiggle_OnScl", "wiggle_TVS", "wiggle_OnScl_lock"]        D = ["visibility_at", "visibility_of", "visibility_dt", "full_txt", "charS_ob_nm", "vis_interpolation",             "vis_back", "rand_vis", "vis_on", "wiggle_OnScl", "wiggle_TVS", "wiggle_OnScl_lock"]        sett = [ "context.scene.{o}[0].{i}".format(o = context.object.name, i= atr ) for atr in filtre() ]        A    = [ "context.scene.{o}[0].{i}".format(o = context.object.name, i= atr ) for atr in A ]         B    = [ "context.scene.{o}[0].{i}".format(o = context.object.name, i= atr ) for atr in B ]         C    = [ "context.scene.{o}[0].{i}".format(o = context.object.name, i= atr ) for atr in C ]         D    = [ "context.scene.{o}[0].{i}".format(o = context.object.name, i= atr ) for atr in D ]         liste = [ A, B, C, D ]        for atr in liste :            for a, s in zip(atr, sett):                exec(a+" = "+s)        return {'FINISHED'}class RootOperator(bpy.types.Operator):    """Toggl select handle"""    bl_idname = "object.root_tx_operator"    bl_label = "Toggl select handles"    bl_options = {'REGISTER', 'UNDO'}    @classmethod    def poll(cls, context):                obj = False        if context.active_object != None:            if '_IK' in context.active_object.name:                obj = True        return obj is not False    def execute(self, context):        name = context.active_object.name        if not name.endswith("_IK"):            head, sep, tail = name.partition('_IK')            bpy.ops.object.select_all(action='DESELECT')            context.scene.objects.active = bpy.data.objects[ head + "_IK" ]            context.active_object.select = True            bpy.ops.view3D.view_selected(use_all_regions=False)        else:            bpy.ops.object.select_all(action='DESELECT')            context.scene.objects.active = bpy.data.objects[ name + "_LOC" ]            context.active_object.select = True            _ = bpy.context.object.empty_draw_size            bpy.context.object.empty_draw_size = 4            bpy.ops.view3D.view_selected(use_all_regions=False)            bpy.context.object.empty_draw_size = _                return {'FINISHED'}class LockPosOperator(bpy.types.Operator):    """Lock start at curent Location"""    bl_idname = "object.lock_sttxt_operator"    bl_label = "Lock position"    bl_options = {'REGISTER', 'UNDO'}    @classmethod    def poll(cls, context):        end= False        if context.object != None:            if context.object.name.endswith("_IK_LOC"):                end= True        return end is not False    def execute(self, context):                C     = context        obn   = C.active_object.name        obloc = C.active_object.matrix_world.translation        bpy.ops.object.select_all(action='DESELECT')        if not obn+"KED" in C.scene.objects:            bpy.ops.object.empty_add(type='CUBE', radius=0.2, view_align=False, location=obloc)            C.active_object.name =obn+"KED"            C.scene.objects.active = bpy.data.objects[ obn]            if not obn+"KED" in  C.active_object.constraints:                bpy.ops.object.constraint_add(type='COPY_LOCATION')                C.active_object.constraints["Copy Location"].name =obn+"KED"            C.active_object.constraints[obn+"KED"].target = bpy.data.objects[obn+"KED"]            C.active_object.constraints[obn+"KED"].show_expanded = False            C.active_object.constraints[obn+"KED"].mute = False        else:            if obn+"KED" in  C.active_object.constraints:                C.active_object.constraints[obn+"KED"].mute = True                C.scene.objects.active = bpy.data.objects[ obn+"KED" ]                C.object.select = True                bpy.ops.object.delete(use_global=False)                C.scene.objects.active = bpy.data.objects[ obn]                C.object.select = True                bpy.ops.object.origin_clear()#clearn origine alt+O        return {'FINISHED'}def filtre():#filtre par chaine Loc, Rot, Scal, Vide ?    chan = bpy.data.window_managers["WinMan"].tx_menu    if chan.TXLoc:        return ["start_at", "ofs", "duration", "full_txt", "charS_ob_nm", "interpolation",                 "back", "rand_loc", "vis_on", "wiggle_OnLoc", "wiggle_TVL", "wiggle_OnLoc_lock"]    if chan.TXRot:        return ["rot_start_at", "rot_ofs", "rot_duration", "full_txt", "charS_ob_nm", "rot_interpolation",                 "rot_back", "rand_rot", "vis_on", "wiggle_OnRot", "wiggle_TVR", "wiggle_OnRot_lock"]    if chan.TXScl:        return ["scl_start_at", "scl_ofs", "scl_duration", "full_txt", "charS_ob_nm", "scl_interpolation",                 "scl_back", "rand_scl", "vis_on", "wiggle_OnScl", "wiggle_TVS", "wiggle_OnScl_lock"]    if chan.TXVid:        return ["visibility_at", "visibility_of", "visibility_dt", "full_txt", "charS_ob_nm", "vis_interpolation",                 "vis_back", "rand_vis", "vis_on", "wiggle_OnScl", "wiggle_TVS", "wiggle_OnScl_lock"]    else:        bpy.data.window_managers["WinMan"].tx_menu.TXLoc = True        return ["start_at", "ofs", "duration", "full_txt", "charS_ob_nm", "interpolation",                 "back", "rand_loc", "vis_on", "wiggle_OnLoc", "wiggle_TVL", "wiggle_OnLoc_lock"]def Interpolation_Mode(self, context):    """Interpolation from menu and asign it to Key frame"""    ch = bpy.context.scene.ik_tx_interpo_tool.ik_txt_interpo    op = "context.scene.{o}[0].{i}='{c}'".format(o = context.object.name, i=filtre()[5], c = ch )    exec(op)    #print(op)class Interpolation_Mode_sett(PropertyGroup):    ik_txt_interpo = EnumProperty(        name="Interpolation Mode:",        description="Apply interpolation to active range.",        update = Interpolation_Mode,                items = (        ('linear',   "Linear",     "","IPO_LINEAR",1),        ('inSine',     "Sinusoidal in", "","IPO_SINE",2),        ('outSine',     "Sinusoidal out", "","MOVE_DOWN_VEC",3),        ('inOutSine',     "Sinusoidal inOut", "","MOVE_DOWN_VEC",4),        ('outInSine',     "Sinusoidal outIn", "","MOVE_DOWN_VEC",5),        ('inCubic',    "Cubic in",      "","IPO_CUBIC",6),        ('outCubic',    "Cubic out",      "","MOVE_DOWN_VEC",7),        ('inOutCubic',    "Cubic inOut",      "","MOVE_DOWN_VEC",8),        ('outInCubic',    "Cubic outIn",      "","MOVE_DOWN_VEC",9),        ('inQuart',    "Quartic in",    "","IPO_QUART",10),        ('outQuart',    "Quartic out",    "","MOVE_DOWN_VEC",11),        ('inOutQuart',    "Quartic inOut",    "","MOVE_DOWN_VEC",12),        ('outInQuart',    "Quartic outIn",    "","MOVE_DOWN_VEC",13),        ('inQuint',    "Quintic in",    "","IPO_QUINT",14),        ('outQuint',    "Quintic out",    "","MOVE_DOWN_VEC",15),        ('inOutQuint',    "Quintic inOut",    "","MOVE_DOWN_VEC",16),        ('outInQuint',    "Quintic outIn",    "","MOVE_DOWN_VEC",17),        ('inExpo',     "Exponential in", "","IPO_EXPO",18),        ('outExpo',     "Exponential out", "","MOVE_DOWN_VEC",19),        ('inOutExpo',     "Exponential inOut", "","MOVE_DOWN_VEC",20),        ('outInExpo',     "Exponential outIn", "","MOVE_DOWN_VEC",21),        ('inCirc',     "Circular in",    "","IPO_CIRC",22),        ('outCirc',     "Circular out",    "","MOVE_DOWN_VEC",23),        ('inOutCirc',     "Circular inOut",    "","MOVE_DOWN_VEC",24),        ('outInCirc',     "Circular outIn",    "","MOVE_DOWN_VEC",25),        ('inBack',     "Back in",        "","IPO_BACK",26),        ('outBack',     "Back out",        "","MOVE_DOWN_VEC",27),        ('inOutBack',     "Back inOut",        "","MOVE_DOWN_VEC",28),        ('outInBack',     "Back outIn",        "","MOVE_DOWN_VEC",29),        ('inBounce',   "Bounce in",      "","IPO_BOUNCE",30),        ('outBounce',   "Bounce out",      "","MOVE_DOWN_VEC",31),        ('inOutBounce',   "Bounce inOut",      "","MOVE_DOWN_VEC",32),        ('outInBounce',   "Bounce outIn",      "","MOVE_DOWN_VEC",33),        ('inElastic',  "Elastic in",     "","IPO_ELASTIC",34),                ('outElastic',  "Elastic out",     "","MOVE_DOWN_VEC",35),                ('inOutElastic',  "Elastic inOut",     "","MOVE_DOWN_VEC",36)),                # ('outInElastic',  "Elastic outIn",     "","MOVE_DOWN_VEC",36)),                default='inBack',         )class IKTxtTextPanel(bpy.types.Panel):    """Creates a Panel in the 3D view tools"""    bl_label = "Text"    bl_space_type = 'VIEW_3D'    bl_region_type = 'TOOLS'    bl_context = 'objectmode'    bl_category = "IK-Text Effects"    def draw(self, context):        layout = self.layout        obj = context.object        row = layout.row()        row.prop(context.scene, 'ik_font_path', icon="FILE_FONT")        row = layout.row()        row.prop(context.scene, "edit_ik_text", text="", icon = "OUTLINER_DATA_FONT")        row = layout.row()        row.operator("object.add_txt_operator", icon = "ZOOMIN")        row = layout.row()        row.operator("object.erase_tx_op", icon="PANEL_CLOSE")        layout.separator()        row = layout.row()        row.operator("object.ik_tx_reload_op", text="Reload session", icon="SCENE_DATA")class IKTxtEffectsPanel(bpy.types.Panel):    """Creates a Panel in the 3D view tools"""    bl_label = "Effects"    bl_space_type = 'VIEW_3D'    bl_region_type = 'TOOLS'    bl_context = 'objectmode'    bl_category = "IK-Text Effects"    selected = "tool_objectTrace"    def draw(self, context):        tx_bool = bpy.context.window_manager.tx_menu        scene = context.scene        if not context.active_object == None:            Disque = eval(scene.IKAnimatedTx)            if ( context.object.name in Disque ) and ( getattr(context.scene,  context.object.name , None) != None ) :                """Props                 [                 "start_at" 0, "ofs" 1,                 "duration" 2, "full_txt" 3,                 "charS_ob_nm" 4, "interpolation" 5,                 "back" 6, "rand" 7, "vis_on" 8,                 "wiggle_OnLoc" 9, "wiggle_TV(L/R/S)" 10,                "wiggle_OnLoc_lock" 11,                ]                """                               ftr = filtre() # >> ask chaine                 intrp = "context.scene.{o}[0].{i}".format(o = context.active_object.name, i=ftr[5] )                wigg = "context.scene.{o}[0].{i}".format(o = context.active_object.name, i=ftr[9] )                intrp = eval(intrp)                wigg = eval(wigg)                op = "context.scene.{o}[0]".format(o = context.object.name)                op = eval(op)                layout = self.layout                                interpolation_tool = scene.ik_tx_interpo_tool #--------------------------Interpolation                row = layout.row(align=True)                row.prop(tx_bool, "TXLoc", text="loc", icon = "MAN_TRANS")#Auto apply                row.prop(tx_bool, "TXRot", text="rot", icon = "MAN_ROT")#Auto apply                row.prop(tx_bool, "TXScl", text="scale", icon = "MAN_SCALE")#Auto apply                row.prop(tx_bool, "TXVid", text="Vide", icon = "FONT_DATA")#Auto apply                row = layout.row(align=True)                row.prop(op, ftr[0] )                if tx_bool.TXVid :                    row = layout.row(align=True)                    row.prop(op, ftr[8], text="type-on", icon="RESTRICT_VIEW_OFF" )                                if not tx_bool.TXVid :                    row = layout.row(align=True)                    row.prop(op, ftr[1] )                row.prop(op, ftr[7], text="", icon="RNDCURVE" )#bool rand                row = layout.row()                row.prop(op, ftr[2] )                          if tx_bool.TXVid :                    layout.separator()                    layout.separator()                                if not tx_bool.TXVid :                    row = layout.row()                    row.label(text="Wiggle:")                    row = layout.row(align=True)                    row.prop(op, ftr[10], text="", slider = True )                    if wigg : row.prop(op, ftr[11], text="", icon="NDOF_DOM" )#bool rand                    row.prop(op, ftr[9], text="", icon="FORCE_TURBULENCE" )#bool rand                row = layout.row()                tt = "Easing: "+intrp                row.label(text=tt, icon="PLAY_AUDIO")                row = layout.row()                row.prop(interpolation_tool, "ik_txt_interpo", text="") #---------------Interpolation                                if "Back" in intrp:                    row = layout.row()                    row.prop(op, ftr[6], slider=True)                row = layout.row()                row.label(text="settings")                row = layout.row()                row.operator("object.past_tx_operator", text="Align", icon="ALIGN")                row = layout.row()                row.operator("object.bake_tx_op", icon="FILE_TICK", text ="Bake text" )class IKTxtAparPanel(bpy.types.Panel):    """Creates a Panel in the 3D view tools"""    bl_label = "Appearance"      bl_space_type = 'VIEW_3D'    bl_region_type = 'TOOLS'    bl_context = 'objectmode'    bl_category = "IK-Text Effects"    def draw(self, context):        layout = self.layout        if ( getattr(context.active_object, "data", None) != None ) and ( context.active_object.type == 'FONT' ) :            if context.active_object.data.name in bpy.data.curves:                curve = bpy.data.curves[context.active_object.data.name]                row = layout.row()                row.operator("object.syncchar_operator", text="Update chars", icon = "FILE_REFRESH")                row = layout.row(align=True)                row.label(text="Resolution:")                row = layout.row(align=True)                row.prop(curve, "resolution_u", text="Preview U")                row.prop(curve, "render_resolution_u", text="Render U")                row = layout.row(align=True)                row.label(text="Font:")                row = layout.row()                row.prop(curve, "shear")                split = layout.split(align=True)                col = split.column(align=True)                col.label(text="Modification:")                col.prop(curve, "offset")                col.prop(curve, "extrude")                col = split.column(align=True)                col.label(text="Bevel:")                col.prop(curve, "bevel_depth", text="Depth")                col.prop(curve, "bevel_resolution", text="Resolution")class IKTxtExtraPanel(bpy.types.Panel):    """Creates a Panel in the 3D view tools"""    bl_label = "Extra"    bl_space_type = 'VIEW_3D'    bl_region_type = 'TOOLS'    bl_context = 'objectmode'    bl_category = "IK-Text Effects"    @classmethod    def poll(cls, context):        view = context.space_data        return (view)    def draw(self, context):        """Props         [         "start_at" 0, "ofs" 1,         "duration" 2, "full_txt" 3,         "charS_ob_nm" 4, "interpolation" 5,         "back" 6, "rand" 7, "vis_on" 8,         "wiggle_loc" 9,         ]        """        view = context.space_data        scene = context.scene        layout = self.layout                                               row = layout.row(align=True)        row.label(text="Handles:")          row = layout.row(align=True)        row.operator("object.root_tx_operator", text="start / end", icon = "RESTRICT_VIEW_OFF")        row = layout.row(align=True)        row.operator("object.lock_sttxt_operator", icon="NDOF_DOM", text="freeze")                            row = layout.row(align=True)        row.label(text="Display:")                            row = layout.row(align=True)        row.prop(view, "show_relationship_lines", text="Lines", icon ="CURVE_PATH")        row.prop(view, "show_only_render", icon ="SCENE", text="View")def register():    bpy.utils.register_module(__name__)    bpy.types.Scene.ik_tx_interpo_tool = PointerProperty(type=Interpolation_Mode_sett)    bpy.types.WindowManager.tx_menu = bpy.props.PointerProperty(type=TxLocRotScl, update=deselect_others)    bpy.types.Scene.ik_font_path = bpy.props.StringProperty \        (        name = "Font Path",        default = "",        description = "Define the root path of the font",        subtype = 'FILE_PATH'        )    bpy.types.Scene.edit_ik_text = bpy.props.StringProperty \        (        name        = "Edite new text",         default     = "Text",         description = "Type new text",        )    bpy.types.Scene.IKAnimatedTx = bpy.props.StringProperty \        (        name        = "IK text Efects",         default     = "{}",#save name anemated txt for reload scen        description = "All text settings",        )    handlers =[ IkTx_LOC, IkTx_ROT, IkTx_SCL, IkTx_Vid ]     for name in handlers: bpy.app.handlers.scene_update_pre.append(name)def unregister():    handlers =[ "IkTx_LOC", "IkTx_ROT", "IkTx_SCL", "IkTx_Vid" ]     for name in handlers:        my_handler_list = bpy.app.handlers.scene_update_pre# alias        fin = len(my_handler_list)                for idx, func in enumerate(reversed(my_handler_list)):            if func.__name__.startswith(name) :                my_handler_list.pop(fin-1-idx)        bpy.context.scene.IKAnimatedTx = "{}"        bpy.utils.unregister_module(__name__)    del bpy.types.WindowManager.tx_menu    del bpy.types.Scene.ik_tx_interpo_tool    del bpy.types.Scene.edit_ik_text    del bpy.types.Scene.IKAnimatedTx    del bpy.types.Scene.ik_font_path    alll = []    for o in bpy.data.objects:        if o.name.endswith("_IK")    : alll.append(o.name)        if o.name.endswith("_LOC")   : alll.append(o.name)        if o.name.endswith("_LOCKED"): alll.append(o.name)        allOB = []        for ob in alll:        if ob.endswith("_IK"):            for o in bpy.data.objects:                if o.name.startswith( ob.replace("_IK", "") ):                    allOB.append(o.name)         if getattr(bpy.context.scene,  ob , None) != None :            exec( "del bpy.types.Scene.{p}".format( p = ob ) )    bpy.ops.object.select_all(action='DESELECT')    for ob in alll + allOB:        if not ob in bpy.data.objects : continue #echap les objets qui existe pas        bpy.data.objects[ ob ].hide_select, bpy.data.objects[ ob ].select = False, True        bpy.ops.object.delete(use_global=False)    if __name__ == "__main__":    register()